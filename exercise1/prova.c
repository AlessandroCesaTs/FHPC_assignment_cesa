#include<stdio.h>
#include<stdlib.h>
#include<omp.h>
#include<time.h>

void write_pgm_image(void *image,int size,const char *image_name){

/*Function for writing an image,given as size x size a matrix of 0s and 1s, in a pbm file
 * image        : a pointer to the memory region that contains the image
 * size         : size of the image
 * image_name   : the name of the file to be written
 */

  FILE* image_file; 
  image_file = fopen(image_name, "w"); 

  fprintf(image_file, "P5\n# generated by\n# Alessandro Cesa\n%d %d\n%d\n", size, size, 1);

  fwrite( image, 1, size*size, image_file); 

  fclose(image_file); 
  return ;
}

void initialize(int size,char* name){
    char *grid=(char *)malloc(size*size * sizeof(char) );
   srand(time(NULL) );
#pragma omp parallel shared(grid,size,name) 
   {
#pragma omp for schedule(static)
    for (int i=0;i<size*size;i++){
        grid[i]=(char)(rand()%2);
     }
    write_pgm_image((void *) grid, size, name);
   }
    free(grid);
    return;
}

void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}

char evaluate_cell(char** grid,int size,int i,int j){
    int u_i,d_i,l_j,r_j;
    int neighborhood;
    char* g=*grid;
    if (i==0){
        u_i=size-1;
        d_i=i+1;
    }else if(i==size-1){
        u_i=i-1;
        d_i=0;
    }else{
        u_i=i-1;
        d_i=i+1;
    }

    if(j==0){
        l_j=size-1;
        r_j=j+1;
    }else if(j==size-1){
        l_j=j-1;
        r_j=0;
    }else{
        l_j=j-1;
        r_j=j+1;
    }

    neighborhood=(int)g[u_i*size+l_j]+(int)g[u_i*size+j]+(int)g[u_i*size+r_j]+(int)g[i*size+l_j]+(int)g[i*size+r_j]+(int)g[d_i*size+l_j]+(int)g[d_i*size+j]+(int)g[d_i*size+r_j];
    if (neighborhood==2 || neighborhood==3){
            return (char)1;
        }else{
            return (char)0;
        }
}

void print_grid(char** grid,int size){
       char* g=*grid;
    for (int i=0;i<size;i++){
        for (int j=0;j<size;j++){
            printf(" %d ",g[i*size+j]);
        }
        printf("\n");
    }
    printf("\n");
}

void upgrade_cell(char** grid,int size,int i,int j){
    char* g=*grid;
    g[i*size+j]=evaluate_cell(grid,size,i,j);
}


void run_episode_ordered(char** grid,int size){
    for (int i=0;i<size;i++){
        for (int j=0;j<size;j++){
            upgrade_cell(grid,size,i,j);
        }
    }
}

void run_episode_static(char** grid,int size){
	print_grid(grid,size);
    char **eval = (char **)malloc(size * sizeof(char *));
    for (int i=0;i<size;i++){
        eval[i]=(char*)malloc(size * sizeof(char));
        for (int j=0;j<size;j++){
            eval[i][j]=evaluate_cell(grid,size,i,j);
        }
    }
char* g=*grid;
    for (int i=0;i<size;i++){
	    for (int j=0;j<size;j++){
           g[i*size+j]=eval[i][j];
	    }
    }
    print_grid(grid,size);
    free(eval);
}


int main(int argc,char** argv){

    initialize(100,"test.pgm");

    void* image=NULL;
    int xsize;
    int ysize;
    int maxval;
    char* char_image;
    read_pgm_image(&image,&maxval, &xsize, &ysize, "test.pgm");
    char_image=(char*)image;
    ysize=0;
    maxval=0;
    free(image);
    char_image=(char*)image;
    for (int t=0;t<20;t++){
   	 run_episode_ordered(&char_image,xsize);
    	 if (t % 5 == 0) {
	 	 char new_image_name[20];  // Adjust the array size as needed
    		snprintf(new_image_name, sizeof(new_image_name), "test_%d.pgm", t);
    		write_pgm_image((void*)char_image, xsize, new_image_name);
		}
	}

    return 0;

    
}
